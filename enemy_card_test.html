<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>敌人卡片模块测试</title>
    <link rel="stylesheet" href="enemy_editor.css">
    <link rel="stylesheet" href="enemy_card.css">
</head>
<body class="demo-body">

    <div class="demo-header">
        <h1>敌人卡片模块演示</h1>
        <p>右键点击卡片可进行编辑。</p>
        <button id="add-random-btn" class="btn primary">随机添加一张卡片</button>
    </div>

    <div class="cards-container" id="cards-container">
        <!-- 卡片将在这里生成 -->
    </div>

    <!-- 编辑器模态框 -->
    <div id="editor-modal" class="modal">
        <div class="modal-content">
            <span class="close-modal">&times;</span>
            <!-- 编辑器内容将通过 JS 动态注入 -->
            <div id="editor-injection-point"></div>
        </div>
    </div>

    <!-- 脚本 -->
    <script src="敌人数据块.js"></script>
    <script src="enemy_card.js"></script>
    
    <!-- 引入编辑器模板 -->
    <script src="enemy_editor_template.js"></script>
    
    <script>
        // 动态注入编辑器 HTML
        // 这模拟了类似 #include 的行为，解决了本地 file:// 环境下 iframe 跨域和 fetch 限制的问题
        if (typeof ENEMY_EDITOR_HTML !== 'undefined') {
            document.getElementById('editor-injection-point').innerHTML = ENEMY_EDITOR_HTML;
        } else {
            console.error('无法加载编辑器模板');
        }
    </script>

    <!-- 引入编辑器逻辑 (必须在 HTML 注入之后) -->
    <script src="enemy_editor.js"></script>

    <script>
        // 1. 初始化
        const cardsContainer = document.getElementById('cards-container');
        const modal = document.getElementById('editor-modal');
        const closeModal = document.querySelector('.close-modal');
        const addRandomBtn = document.getElementById('add-random-btn');
        // enemyForm 是在动态注入后存在的
        const enemyForm = document.getElementById('enemyForm');
        
        let currentEditingCard = null; // 当前正在编辑的卡片 DOM 元素
        let currentEditingData = null; // 当前正在编辑的数据对象

        // 2. 随机添加卡片
        addRandomBtn.addEventListener('click', () => {
            if (typeof ADVERSARY !== 'undefined' && ADVERSARY.length > 0) {
                const randomIndex = Math.floor(Math.random() * ADVERSARY.length);
                const randomEnemy = JSON.parse(JSON.stringify(ADVERSARY[randomIndex])); // 深拷贝
                const card = renderEnemyCard(randomEnemy);
                cardsContainer.appendChild(card);
            } else {
                alert('未找到敌人数据 (ADVERSARY)');
            }
        });

        // 初始化加载几个
        if (typeof ADVERSARY !== 'undefined') {
             for(let i=0; i<3; i++) {
                 addRandomBtn.click();
             }
        }

        // 3. 处理编辑事件
        document.addEventListener('edit-enemy', (e) => {
            const { enemyData, cardElement } = e.detail;
            currentEditingData = enemyData;
            currentEditingCard = cardElement;
            
            fillEditor(enemyData);
            modal.style.display = 'block';
        });

        // 4. 关闭模态框
        closeModal.addEventListener('click', () => {
            modal.style.display = 'none';
        });
        
        window.onclick = function(event) {
            if (event.target == modal) {
                modal.style.display = "none";
            }
        }

        // 5. 填充编辑器逻辑
        function fillEditor(data) {
            document.getElementById('name').value = data['名称'] || '';
            document.getElementById('tier').value = data['位阶'] || '';
            document.getElementById('category').value = data['种类'] || '';
            document.getElementById('intro').value = data['简介'] || '';
            document.getElementById('tactics').value = data['动机与战术'] || '';
            document.getElementById('experiences').value = data['经历'] || '';
            document.getElementById('difficulty').value = data['难度'] || '';
            document.getElementById('hp').value = data['生命点'] || '';
            document.getElementById('stress').value = data['压力点'] || '';
            document.getElementById('majorThreshold').value = data['重度伤害阈值'] || '';
            document.getElementById('severeThreshold').value = data['严重伤害阈值'] || '';
            document.getElementById('attackHit').value = data['攻击命中'] || '';
            document.getElementById('attackWeapon').value = data['攻击武器'] || '';
            document.getElementById('attackRange').value = data['攻击范围'] || '';
            document.getElementById('attackDamage').value = data['攻击伤害'] || '';
            document.getElementById('attackAttr').value = data['攻击属性'] || '';

            // 特性
            const traitsContainer = document.getElementById('traitsContainer');
            const addTraitBtn = document.getElementById('addTraitBtn');
            
            traitsContainer.innerHTML = '';
            
            if (data['特性']) {
                data['特性'].forEach(trait => {
                    addTraitBtn.click(); 
                    // 获取刚添加的元素 (最后一个)
                    const items = traitsContainer.querySelectorAll('.trait-item');
                    const newItem = items[items.length - 1];
                    
                    if (newItem) {
                        newItem.querySelector('.trait-name').value = trait['名称'] || '';
                        newItem.querySelector('.trait-type').value = trait['类型'] || '';
                        newItem.querySelector('.trait-desc').value = trait['特性描述'] || '';
                    }
                });
            }
        }

        // 6. 保存修改 (覆盖 submit)
        if (enemyForm) {
            enemyForm.addEventListener('submit', (e) => {
                // e.preventDefault() 在 enemy_editor.js 中已经被调用了，但这里为了确保逻辑正确，不依赖它的顺序
                // 我们需要获取表单数据并更新 currentEditingData
                
                if (!currentEditingData || !currentEditingCard) return;

                const formData = new FormData(enemyForm);
                
                // 更新数据对象
                currentEditingData['名称'] = formData.get('名称');
                currentEditingData['位阶'] = formData.get('位阶');
                currentEditingData['种类'] = formData.get('种类');
                currentEditingData['简介'] = formData.get('简介');
                currentEditingData['动机与战术'] = formData.get('动机与战术');
                currentEditingData['经历'] = formData.get('经历');
                currentEditingData['难度'] = formData.get('难度');
                currentEditingData['生命点'] = formData.get('生命点');
                currentEditingData['压力点'] = formData.get('压力点');
                currentEditingData['重度伤害阈值'] = formData.get('重度伤害阈值');
                currentEditingData['严重伤害阈值'] = formData.get('严重伤害阈值');
                currentEditingData['攻击命中'] = formData.get('攻击命中');
                currentEditingData['攻击武器'] = formData.get('攻击武器');
                currentEditingData['攻击范围'] = formData.get('攻击范围');
                currentEditingData['攻击伤害'] = formData.get('攻击伤害');
                currentEditingData['攻击属性'] = formData.get('攻击属性');

                // 更新特性
                currentEditingData['特性'] = [];
                const traitItems = document.getElementById('traitsContainer').querySelectorAll('.trait-item');
                traitItems.forEach(item => {
                    const name = item.querySelector('.trait-name').value;
                    if (name) {
                        currentEditingData['特性'].push({
                            '名称': name,
                            '类型': item.querySelector('.trait-type').value,
                            '特性描述': item.querySelector('.trait-desc').value
                        });
                    }
                });

                // 重新渲染卡片
                // 简单粗暴的方法：创建一个新卡片替换旧卡片
                const newCard = renderEnemyCard(currentEditingData);
                cardsContainer.replaceChild(newCard, currentEditingCard);
                
                // 更新引用
                currentEditingCard = newCard;

                modal.style.display = 'none';
            });
        } else {
            console.error('enemyForm not found after injection!');
        }

    </script>
</body>
</html>
